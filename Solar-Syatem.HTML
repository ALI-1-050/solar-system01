<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Animated Solar System</title>
  <style>
    :root{--bg:#02030a;--panel:rgba(255,255,255,0.06);--glass:rgba(255,255,255,0.04)}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{background: radial-gradient(ellipse at center, #041022 0%, #000611 60%, #000000 100%);color:#fff;display:flex;flex-direction:column}
    header{padding:12px 18px;display:flex;gap:12px;align-items:center}
    h1{font-size:18px;margin:0;font-weight:600}
    .container{flex:1;display:flex;gap:12px;padding:12px}
    .canvas-wrap{flex:1;position:relative;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);box-shadow:0 6px 20px rgba(2,6,23,0.6);overflow:hidden}
    canvas{width:100%;height:100%;display:block}
    .panel{width:320px;min-width:220px;padding:12px;border-radius:12px;background:var(--panel);backdrop-filter:blur(6px);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
    label{display:block;font-size:13px;color:#cbd5e1;margin-top:10px}
    .row{display:flex;gap:8px;align-items:center;margin-top:8px}
    .btn{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:var(--glass);cursor:pointer}
    input[type=range]{width:100%}
    .small{font-size:12px;color:#9aa6b2}
    footer{padding:8px 12px;font-size:12px;color:#9aa6b2}
    .credits{margin-top:12px;font-size:12px}
    @media (max-width:880px){.container{flex-direction:column}.panel{width:auto}}
  </style>
</head>
<body>
  <header>
    <h1>Animated Solar System (HTML + Canvas)</h1>
    <div class="small">Click & drag on canvas to pan, scroll to zoom</div>
  </header>
  <div class="container">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="space"></canvas>
    </div>
    <aside class="panel">
      <div><strong>Controls</strong></div>
      <div class="row">
        <button class="btn" id="playPause">Pause</button>
        <button class="btn" id="reset">Reset View</button>
      </div>

      <label>Animation Speed <span id="speedVal">1.0×</span></label>
      <input id="speed" type="range" min="0" max="4" step="0.05" value="1">

      <label>Show Orbits</label>
      <div class="row"><input id="toggleOrbits" type="checkbox" checked> <span class="small">Orbits visible</span></div>

      <label>Show Planet Trails</label>
      <div class="row"><input id="toggleTrails" type="checkbox"> <span class="small">Trails add motion effect</span></div>

      <label>Scale (Zoom)</label>
      <input id="zoom" type="range" min="0.2" max="2.5" step="0.01" value="1">

      <div class="credits">This demo uses a simplified, non-to-scale model for visual clarity. Planets' sizes, distances and speeds are exaggerated so orbits and motion are visible.</div>
    </aside>
  </div>
  <footer>Tip: try resizing the window or toggling trails for a nicer effect.</footer>

<script>
// --- Setup canvas and device pixel ratio handling ---
const canvas = document.getElementById('space');
const ctx = canvas.getContext('2d');
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

// --- Scene state ---
let running = true;
let globalSpeed = 1;
let showOrbits = true;
let showTrails = false;
let zoom = 1;

// Camera / pan
let cam = {x:0,y:0,scale:1};
let isDragging=false, lastMouse=null;

// Planets data (simplified): name, color, radius (visual), orbitalRadius, orbitalPeriod (seconds), initialAngle
const planets = [
  {name:'Mercury', color:'#b1b1b1', radius:3, orbit:40, period:4.8, angle:0},
  {name:'Venus',   color:'#e0c07a', radius:5, orbit:60, period:12.1, angle:1},
  {name:'Earth',   color:'#63a4ff', radius:6, orbit:85, period:16, angle:2},
  {name:'Mars',    color:'#d86b3a', radius:4, orbit:110, period:30, angle:3},
  {name:'Jupiter', color:'#c9956a', radius:12, orbit:160, period:200, angle:0.5},
  {name:'Saturn',  color:'#e0cf9a', radius:10, orbit:210, period:400, angle:1.5},
  {name:'Uranus',  color:'#8fe0d6', radius:8, orbit:260, period:900, angle:2.5},
  {name:'Neptune', color:'#4a6ef3', radius:8, orbit:300, period:1600, angle:4}
];

// Trails storage (circular buffer)
const trails = planets.map(()=>[]);
const maxTrailLength = 120;

// Stars background
const stars = [];
function genStars(count=200){
  for(let i=0;i<count;i++){
    stars.push({x:Math.random()*2000-1000,y:Math.random()*2000-1000,size:Math.random()*1.6,alpha:0.4+Math.random()*0.6});
  }
}
genStars(250);

// Time
let last = performance.now();
let t0 = performance.now();

function worldToScreen(x,y){
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  return {x: cx + (x-cam.x)*cam.scale, y: cy + (y-cam.y)*cam.scale };
}

function screenToWorld(x,y){
  const rect = canvas.getBoundingClientRect();
  const cx = rect.width/2, cy = rect.height/2;
  return {x: cam.x + (x-cx)/cam.scale, y: cam.y + (y-cy)/cam.scale};
}

// Interaction: pan (drag) and zoom (wheel)
canvas.addEventListener('pointerdown', e=>{
  isDragging=true; canvas.setPointerCapture(e.pointerId); lastMouse={x:e.clientX,y:e.clientY};
});
canvas.addEventListener('pointermove', e=>{
  if(!isDragging || !lastMouse) return;
  const dx = (e.clientX - lastMouse.x) / cam.scale;
  const dy = (e.clientY - lastMouse.y) / cam.scale;
  cam.x -= dx; cam.y -= dy;
  lastMouse = {x:e.clientX,y:e.clientY};
});
canvas.addEventListener('pointerup', e=>{isDragging=false; lastMouse=null; canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId)});
canvas.addEventListener('wheel', e=>{
  e.preventDefault(); const delta = -e.deltaY * 0.001;
  const old = cam.scale;
  cam.scale = Math.min(4, Math.max(0.2, cam.scale*(1+delta)));
  // zoom to pointer
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const before = screenToWorld(mx, my);
  const after = screenToWorld(mx, my);
  cam.x += (before.x - after.x); cam.y += (before.y - after.y);
}, {passive:false});

// UI bindings
document.getElementById('playPause').addEventListener('click', ()=>{running = !running; document.getElementById('playPause').textContent = running? 'Pause':'Play'; if(running) last = performance.now();});
document.getElementById('speed').addEventListener('input', e=>{globalSpeed = +e.target.value; document.getElementById('speedVal').textContent = globalSpeed.toFixed(2) + '×';});
document.getElementById('toggleOrbits').addEventListener('change', e=>{showOrbits = e.target.checked});
document.getElementById('toggleTrails').addEventListener('change', e=>{showTrails = e.target.checked; if(!showTrails) trails.forEach(arr=>arr.length=0)});
document.getElementById('zoom').addEventListener('input', e=>{zoom = +e.target.value; cam.scale = zoom});
document.getElementById('reset').addEventListener('click', ()=>{cam={x:0,y:0,scale:1}; document.getElementById('zoom').value = 1; zoom=1});

// Draw helpers
function drawBackground(){
  // fill
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
  // stars
  ctx.save();
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  for(const s of stars){
    const p = worldToScreen(s.x, s.y);
    ctx.globalAlpha = s.alpha;
    ctx.beginPath(); ctx.arc(p.x, p.y, s.size*cam.scale, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
  }
  ctx.restore();
}

function drawSun(){
  const p = worldToScreen(0,0);
  const sunRadius = 18 * cam.scale;
  // glow
  const g = ctx.createRadialGradient(p.x,p.y,sunRadius*0.2,p.x,p.y,sunRadius*3);
  g.addColorStop(0, 'rgba(255,210,100,0.9)');
  g.addColorStop(0.5,'rgba(255,160,30,0.12)');
  g.addColorStop(1,'rgba(255,120,0,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x,p.y,sunRadius*3,0,Math.PI*2); ctx.fill();
  // core
  ctx.beginPath(); ctx.arc(p.x,p.y,sunRadius,0,Math.PI*2); ctx.fillStyle = 'gold'; ctx.fill();
}

function drawOrbit(r){
  if(!showOrbits) return;
  const center = worldToScreen(0,0);
  ctx.beginPath(); ctx.ellipse(center.x, center.y, r*cam.scale, r*cam.scale, 0, 0, Math.PI*2);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = Math.max(1, 1*cam.scale); ctx.stroke();
}

function drawPlanet(px,py,planet){
  const p = worldToScreen(px,py);
  // trail handled separately
  ctx.beginPath(); ctx.arc(p.x,p.y, planet.radius*cam.scale, 0, Math.PI*2);
  ctx.fillStyle = planet.color; ctx.fill();
  // simple label
  ctx.font = `${10*cam.scale}px system-ui`; ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(planet.name, p.x + (6*cam.scale), p.y - (6*cam.scale));
}

function drawTrails(){
  if(!showTrails) return;
  for(let i=0;i<planets.length;i++){
    const tr = trails[i];
    if(tr.length<2) continue;
    ctx.beginPath();
    for(let j=0;j<tr.length;j++){
      const p = worldToScreen(tr[j].x, tr[j].y);
      if(j===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.strokeStyle = planets[i].color;
    ctx.globalAlpha = 0.55;
    ctx.lineWidth = Math.max(1, Math.min(3, 2*cam.scale));
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

// Main loop
function update(now){
  const dt = Math.min(60, (now - last)/1000) * globalSpeed; // seconds scaled
  last = now;
  if(running){
    // advance angles
    for(const p of planets){
      // angle change proportional to dt/period
      p.angle += (dt / p.period) * (Math.PI*2);
    }
  }

  // draw
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  drawBackground();

  // draw orbits
  for(const p of planets){ drawOrbit(p.orbit); }

  // draw trails
  // update trails
  for(let i=0;i<planets.length;i++){
    const p = planets[i];
    const x = Math.cos(p.angle) * p.orbit;
    const y = Math.sin(p.angle) * p.orbit;
    if(showTrails){
      trails[i].push({x,y});
      if(trails[i].length>maxTrailLength) trails[i].shift();
    }
  }
  drawTrails();

  // draw sun
  drawSun();

  // draw planets
  for(const p of planets){
    const x = Math.cos(p.angle) * p.orbit;
    const y = Math.sin(p.angle) * p.orbit;
    drawPlanet(x,y,p);
  }

  requestAnimationFrame(update);
}

// initialize camera scale
cam.scale = zoom;
requestAnimationFrame(update);

// handle high DPI initial size when ready
window.addEventListener('load', ()=>{fitCanvas(); last = performance.now();});
</script>
</body>
</html>
